free c: channel.
free p: channel.

type skey.
type pkey.
type random.
type SharedSecret.
type cipher.

fun genskey(): skey [private].
fun genpkey(): pkey.

fun skey2b(skey): bitstring.
fun pkey2b(pkey): bitstring.

fun h(bitstring): bitstring.

fun encapc(pkey, random): cipher.
fun encapSharedSecret(pkey, random): SharedSecret [private].
fun decap(skey, cipher): SharedSecret [private].
fun ss2b(SharedSecret): bitstring.

equation forall pk: pkey, r:random, sk: skey;
    decap(sk, encapc(pk, r)) = encapSharedSecret(pk, r).

fun sign(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: pkey; checksign(sign(m,k), k) = m.

free s: bitstring [private].
query attacker(s).


(*
reduc forall k:pkey, r:random;
    encap(k, r) = ??.

reduc forall k:skey, m:msg;
    decap(k, m) = ??.
*)

type result.
const done: result.

let alice() = 
    in(c, pk:pkey);
    new r:random; 
        out(c, encapc(pk, r));
    let ss = encapSharedSecret(pk, r) in 
    out(c, sign(ss2b(ss), pk)).
    
let bob(pk: pkey, sk: skey) = 
    in(c, cp:cipher);
    let ss = decap(sk, cp) in
    in(c, hss:bitstring);
    let css = checksign(hss, pk) in
    if css = hss then
        out(c, done);
    let d = done in 0.

process(
    let pk = genpkey() in
    out(c, pk);
    let sk = genskey() in
    !alice() | !bob(pk, sk)
)

